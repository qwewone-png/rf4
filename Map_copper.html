<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>러시안피싱 낚시 스팟 관리</title>
<style>
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #f9f9f9;
    margin: 0; padding: 20px;
    color: #222;
  }
  #app-container {
    max-width: 950px;
    margin: 0 auto;
    background: white;
    box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    border-radius: 8px;
    padding: 15px;
    user-select: none;
  }
  canvas {
    display: block;
    margin: 0 auto;
    cursor: crosshair;
    background-repeat: no-repeat;
    background-position: center;
    background-size: contain;
    border: 1px solid #ccc;
    border-radius: 4px;
  }
  #coordsDisplay {
    text-align: center;
    margin: 8px 0 20px 0;
    font-weight: bold;
    font-family: monospace;
    font-size: 16px;
    color: #555;
  }
  
  .controls-group {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin-top: 15px;
    flex-wrap: wrap; /* 반응형으로 버튼이 여러 줄로 표시될 수 있도록 */
  }
  .controls-group button {
    cursor: pointer;
    padding: 8px 14px;
    background: #3498db;
    border: none;
    color: white;
    font-weight: 600;
    border-radius: 4px;
    transition: background-color 0.3s ease;
  }
  .controls-group button:hover:not(:disabled) { /* 비활성화 상태에서는 호버 효과 없음 */
    background: #2980b9;
  }
  .controls-group button#clear-all-spots-btn {
    background: #e74c3c;
  }
  .controls-group button#clear-all-spots-btn:hover:not(:disabled) {
    background: #c0392b;
  }
  .controls-group button:disabled { /* 비활성화 버튼 스타일 */
    background: #ccc;
    cursor: not-allowed;
  }

  #import-area {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    margin-top: 15px;
    padding: 10px;
    background-color: #f0f0f0;
    border-radius: 5px;
    display: none; /* 기본 숨김 */
  }
  #import-area textarea {
    width: 90%;
    min-height: 80px;
    padding: 8px;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: 14px;
    resize: vertical;
  }
  #import-area button {
    padding: 8px 15px;
    background-color: #2ecc71;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.3s ease;
  }
  #import-area button:hover {
    background-color: #27ae60;
  }

  table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 12px;
  }
  th, td {
    padding: 8px 10px;
    border: 1px solid #ddd;
    text-align: center;
    font-size: 14px;
    vertical-align: middle;
  }
  th {
    background: #2c3e50;
    color: white;
  }
  /* 컬럼 너비 조정 */
  th:nth-child(1), td:nth-child(1) { width: 5%; } /* 순번 */
  th:nth-child(2), td:nth-child(2) { width: 15%; } /* 등록 시간 */
  th:nth-child(3), td:nth-child(3) { width: 12%; } /* 좌표 */
  th:nth-child(4), td:nth-child(4) { width: 8%; } /* 거리 */
  th:nth-child(5), td:nth-child(5) { width: 20%; } /* 미끼정보 */
  th:nth-child(6), td:nth-child(6) { width: 15%; } /* 타겟 어종 */
  th:nth-child(7), td:nth-child(7) { width: 15%; } /* 비고란 */
  th:nth-child(8), td:nth-child(8) { width: 8%; } /* 지우기 */

  button.delete-btn {
    background: #e74c3c;
    border: none;
    color: white;
    cursor: pointer;
    padding: 4px 8px;
    border-radius: 4px;
    font-weight: 600;
    transition: background-color 0.3s ease;
  }
  button.delete-btn:hover {
    background: #c0392b;
  }
  td[contenteditable="true"]:focus {
    outline: 2px solid #4CAF50; /* 편집 중인 셀 강조 */
    background-color: #f9f9f9;
  }
</style>
</head>
<body>
  <div id="app-container">
    <canvas id="fishingMapCanvas"></canvas>
    <div id="coordsDisplay">좌표: 0:0</div>
    
    <div class="controls-group">
        <button id="share-spots-btn">스팟 공유하기</button>
        <button id="import-spots-btn">스팟 가져오기</button>
        <button id="clear-all-spots-btn">모든 스팟 지우기</button>
    </div>

    <div id="import-area">
        <textarea id="import-text-input" placeholder="여기에 공유받은 스팟 데이터를 붙여넣으세요."></textarea>
        <button id="load-import-data-btn">데이터 로드</button>
    </div>

    <table id="spotTable" aria-label="낚시 스팟 목록">
      <thead>
        <tr>
          <th>순번</th>
          <th>등록 시간</th>
          <th>좌표</th> <!-- 제목 변경 -->
          <th>거리 (m)</th>
          <th>미끼정보</th>
          <th>타겟 어종</th>
          <th>비고란</th>
          <th>지우기</th>
        </tr>
      </thead>
      <tbody>
        <!-- 스팟 행이 추가됩니다 -->
      </tbody>
    </table>
  </div>

<script>
// START: LZString (Official Library Code)
// https://github.com/pieroxy/lz-string
// Version 1.4.4 - Full implementation to ensure correctness and Unicode support

var LZString = (function () {
  // private property
  var f = String.fromCharCode;
  var keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  var keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-$";
  var baseReverseDic = {};

  function getBaseValue(alphabet, character) {
    if (!baseReverseDic[alphabet + "_" + character]) {
      baseReverseDic[alphabet + "_" + character] = alphabet.indexOf(character);
    }
    return baseReverseDic[alphabet + "_" + character];
  }

  function _compress(uncompressed, bitsPerChar, getCharFromInt) {
    if (uncompressed == null) return "";
    var i, value,
        context_dictionary = {},
        context_dictionaryToCreate = {},
        context_c = "",
        context_wc = "",
        context_w = "",
        context_enlargeIn = 2, // Compensate for the first entry which should not go in on length 1
        context_dictSize = 3,
        context_numBits = 2,
        context_data = [],
        context_data_val = 0,
        context_data_position = 0;

    for (i = 0; i < uncompressed.length; i += 1) {
      context_c = uncompressed.charAt(i);
      if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {
        context_dictionary[context_c] = context_dictSize++;
        context_dictionaryToCreate[context_c] = true;
      }

      context_wc = context_w + context_c;
      if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {
        context_w = context_wc;
      } else {
        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
          if (context_w.charCodeAt(0) < 256) {
            for (value = 0; value < context_numBits; value++) {
              context_data_val = (context_data_val << 1) | 0;
            }
            context_data.push(f(context_w.charCodeAt(0)));
          } else {
            for (value = 0; value < context_numBits; value++) {
              context_data_val = (context_data_val << 1) | 1;
            }
            context_data.push(f(context_w.charCodeAt(0)));
          }
          context_enlargeIn--;
        } else {
          for (value = 0; value < context_numBits; value++) {
            context_data_val = (context_data_val << 1) | ((context_dictionary[context_w] >>> value) & 1);
          }
        }
        if (context_enlargeIn == 0) {
          context_enlargeIn = Math.pow(2, context_numBits);
          context_numBits++;
        }
        // Add wc to the dictionary.
        context_dictionary[context_wc] = context_dictSize++;
        delete context_dictionaryToCreate[context_w];
        context_w = String(context_c);
      }
    }

    // Output the code for the rest of the buffer
    if (context_w !== "") {
      if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
        if (context_w.charCodeAt(0) < 256) {
          for (value = 0; value < context_numBits; value++) {
            context_data_val = (context_data_val << 1) | 0;
          }
          context_data.push(f(context_w.charCodeAt(0)));
        } else {
          for (value = 0; value < context_numBits; value++) {
            context_data_val = (context_data_val << 1) | 1;
          }
          context_data.push(f(context_w.charCodeAt(0)));
        }
        context_enlargeIn--;
      } else {
        for (value = 0; value < context_numBits; value++) {
          context_data_val = (context_data_val << 1) | ((context_dictionary[context_w] >>> value) & 1);
        }
      }
      context_enlargeIn--;
    }

    // Mark the end of the stream
    for (value = 0; value < context_numBits; value++) {
      context_data_val = (context_data_val << 1) | 0;
    }
    
    // Flush the last chars and general conversion
    while (true) {
      context_data_position++;
      if (context_data_position == bitsPerChar) {
        context_data_position = 0;
        context_data.push(getCharFromInt(context_data_val));
        context_data_val = 0;
      } else {
        context_data_val = (context_data_val << 1);
      }
      if (context_dictSize > Math.pow(2, context_numBits -1)) {
        context_numBits++;
      }
    }
    // eslint-disable-next-line no-unreachable
    return context_data.join(''); // This line will only be reached if `true` loop is somehow exited.
  }

  function _decompress(compressed, bitsPerChar, getIntFromChar) {
    if (compressed == null) return "";
    if (compressed == "") return null;
    var dictionary = [],
        next,
        enlargeIn = 4,
        dictSize = 4,
        numBits = 3,
        entry = "",
        result = [],
        i,
        w,
        bits, resb, vertical_shift,
        data = {string: compressed, val: getIntFromChar(0), position: bitsPerChar, index: 1};

    for (i = 0; i < 3; i += 1) {
      dictionary[i] = String(i);
    }

    bits = 0;
    resb = 0;
    vertical_shift = 0;
    while (vertical_shift < bitsPerChar) {
      resb = (resb << 1) | ((data.val >>> data.position--) & 1);
      if (data.position == -1) {
        data.position = 7;
        data.val = getIntFromChar(data.index++);
      }
      vertical_shift++;
    }
    w = f(resb);
    result.push(w);
    while (true) {
      bits = 0;
      resb = 0;
      vertical_shift = 0;
      while (vertical_shift < numBits) {
        resb = (resb << 1) | ((data.val >>> data.position--) & 1);
        if (data.position == -1) {
          data.position = 7;
          data.val = getIntFromChar(data.index++);
        }
        vertical_shift++;
      }
      next = resb;
      if (next === 0 && w === 0) { // Indicates end of stream or malformed data
          return null; 
      }
      if (next >= dictSize) {
        if (next === dictSize) {
          entry = w + w.charAt(0);
        } else {
          return null; // Malformed data
        }
      } else {
        entry = dictionary[next];
      }
      result.push(entry);

      dictionary[dictSize++] = w + entry.charAt(0);
      w = entry;
      if (dictSize == enlargeIn) {
        enlargeIn = Math.pow(2, numBits);
        numBits++;
      }
    }
    // eslint-disable-next-line no-unreachable
    return result.join(''); // This line will only be reached if `true` loop is somehow exited.
  }

  return {
    compressToBase64: function (input) {
      if (input == null) return "";
      var res = _compress(input, 6, function (a) { return keyStrBase64.charAt(a); });
      switch (res.length % 4) { // To produce valid Base64
        default: // When 0, 1 and 2
          return res + '===';
        case 3:
          return res + '=';
        case 2:
          return res + '==';
      }
    },
    decompressFromBase64: function (input) {
      if (input == null) return "";
      if (input == "") return "";
      return _decompress(input.length, 32, function (index) { return getBaseValue(keyStrBase64, input.charAt(index)); });
    },
    compressToEncodedURIComponent: function (input) {
      if (input == null) return "";
      return _compress(input, 6, function (a) { return keyStrUriSafe.charAt(a); }).replace(/ /g, "%20");
    },
    decompressFromEncodedURIComponent: function (input) {
      if (input == null) return "";
      if (input == "") return null;
      return _decompress(input.length, 32, function (index) { return getBaseValue(keyStrUriSafe, input.charAt(index)); });
    },
    compress: function (uncompressed) {
      return _compress(uncompressed, 16, function (a) { return f(a); });
    },
    decompress: function (compressed) {
      if (compressed == null) return "";
      if (compressed == "") return null;
      return _decompress(compressed.length, 16, function (index) { return compressed.charCodeAt(index); });
    }
  };
})();
// END: LZString

(() => {
  const canvas = document.getElementById('fishingMapCanvas');
  const ctx = canvas.getContext('2d');
  const coordsDisplay = document.getElementById('coordsDisplay');
  
  const shareSpotsBtn = document.getElementById('share-spots-btn');
  const importSpotsBtn = document.getElementById('import-spots-btn');
  const clearAllSpotsBtn = document.getElementById('clear-all-spots-btn');
  const importArea = document.getElementById('import-area');
  const importTextInput = document.getElementById('import-text-input');
  const loadImportDataBtn = document.getElementById('load-import-data-btn');

  const spotTableBody = document.querySelector('#spotTable tbody');

  const imageSrc = 'images/maps/map_copper.jpg';

  let mapImage = new Image();
  let isDrawing = false;
  let currentArrow = null;
  let arrows = []; // 저장된 스팟 데이터 배열

  // 실제 좌표 시작/끝 점 (X:24~78, Y:77~23)
  const coordXStart = 24, coordXEnd = 78;
  const coordYStart = 77, coordYEnd = 23;

  const maxWidth = 800;
  const maxHeight = 600;

  // 맵 전체의 가로/세로 실제 길이 (미터)
  const mapWidthMeter = 270;
  const mapHeightMeter = 270;

  // 화살표/핀 색상 팔레트 (main은 반투명, text는 불투명)
  const colorPalette = [
    { main: 'rgba(255, 0, 0, 0.6)', text: 'red' },         // 빨강
    { main: 'rgba(255, 165, 0, 0.6)', text: 'orange' },    // 주황
    { main: 'rgba(0, 128, 0, 0.6)', text: 'green' },       // 초록
    { main: 'rgba(0, 0, 255, 0.6)', text: 'blue' },        // 파랑
    { main: 'rgba(128, 0, 128, 0.6)', text: 'purple' }     // 보라
  ];

  // 논리 좌표(X:Y) -> 캔버스 픽셀 좌표 변환
  function coordToPixel(coord) {
    const px = (coord.x - coordXStart) / (coordXEnd - coordXStart) * canvas.width;
    const py = (coord.y - coordYStart) / (coordYEnd - coordYStart) * canvas.height;
    return { px, py };
  }

  // 캔버스 픽셀 좌표 -> 논리 좌표(X:Y) 변환
  function pixelToCoord(x, y) {
    let cx = coordXStart + (x / canvas.width) * (coordXEnd - coordXStart);
    let cy = coordYStart + (y / canvas.height) * (coordYEnd - coordYStart);
    cx = Math.round(cx); // 정수로 반올림
    cy = Math.round(cy); // 정수로 반올림
    return { x: cx, y: cy };
  }

  // 픽셀 거리 -> 미터 단위 변환 (맵 전체 크기 참고)
  function pixelToMeter(startPxX, startPxY, endPxX, endPxY) {
    // 캔버스의 1픽셀이 실제 몇 미터인지 계산
    const meterPerPixelX = mapWidthMeter / canvas.width;
    const meterPerPixelY = mapHeightMeter / canvas.height;

    // x, y 픽셀 변화량을 각각 미터로 변환
    const dx_meter = (endPxX - startPxX) * meterPerPixelX;
    const dy_meter = (endPxY - startPxY) * meterPerPixelY;
    
    // 유클리드 거리 계산 후 정수로 반올림
    return Math.round(Math.sqrt(dx_meter * dx_meter + dy_meter * dy_meter));
  }


  mapImage.onload = () => {
    let width = mapImage.width;
    let height = mapImage.height;

    const widthRatio = maxWidth / width;
    const heightRatio = maxHeight / height;
    const ratio = Math.min(widthRatio, heightRatio, 1);

    width *= ratio;
    height *= ratio;

    canvas.width = width;
    canvas.height = height;

    canvas.style.backgroundImage = `url('${imageSrc}')`;
    canvas.style.backgroundSize = 'contain';

    loadArrowsFromStorage();
    redraw(); // 캔버스 사이즈가 조정된 후에 화살표를 다시 그립니다.
  };

  // 이미지 로딩 실패 시 에러 메시지 표시
  mapImage.onerror = () => {
    console.error('지도 이미지를 불러올 수 없습니다. 경로를 확인해 주세요:', imageSrc);
    alert('지도 이미지를 불러올 수 없습니다. 경로가 맞는지 확인해 주세요: ' + imageSrc);
  };

  mapImage.src = imageSrc;

  // 화살표 그리기 함수 (저장된 스팟 데이터(spotData) 사용)
  function drawArrow(spotData, index) {
    // 논리 좌표를 픽셀로 변환하여 시작점 얻기
    const startPixel = coordToPixel(spotData.coordStart);
    const startX = startPixel.px;
    const startY = startPixel.py;

    // 드래그 벡터와 시작점을 기준으로 끝점 계산
    const endX = startX - spotData.dragVector.dx;
    const endY = startY - spotData.dragVector.dy;

    const distanceM = spotData.distanceM; // 저장된 거리 사용
    const color = spotData.color; // 저장된 색상 사용
    const coordStart = spotData.coordStart; // 저장된 논리 좌표 사용

    // 화살표 선 (색상)
    ctx.strokeStyle = color.main;
    ctx.lineWidth = 3;
    
    ctx.shadowBlur = 0;
    ctx.shadowColor = 'transparent';

    ctx.beginPath();
    ctx.moveTo(startX, startY);
    ctx.lineTo(endX, endY);
    ctx.stroke();

    const headLen = 15;
    const angle = Math.atan2(endY - startY, endX - startX);

    // 화살표 머리 (색상)
    ctx.fillStyle = color.main;
    ctx.beginPath();
    ctx.moveTo(endX, endY);
    ctx.lineTo(endX - headLen * Math.cos(angle - Math.PI / 7), endY - headLen * Math.sin(angle - Math.PI / 7));
    ctx.lineTo(endX - headLen * Math.cos(angle + Math.PI / 7), endY - headLen * Math.sin(angle + Math.PI / 7));
    ctx.closePath();
    ctx.fill();

    // 거리(m) 텍스트 (색상)
    const textX = startX + (endX - startX) * 0.3 - 10 * Math.sin(angle);
    const textY = startY + (endY - startY) * 0.3 + 10 * Math.cos(angle);

    ctx.fillStyle = color.text; // 메인 색상으로 텍스트 채우기
    ctx.font = '16px monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(`${distanceM}m`, textX, textY);

    // 시작 지점에 원형 핀 및 인덱스 숫자 표시
    const pinRadius = 10; // 핀 크기 더 작게
    ctx.beginPath();
    ctx.fillStyle = color.main; // 핀 채우기 색상
    ctx.arc(startX, startY, pinRadius, 0, 2 * Math.PI);
    ctx.fill();

    ctx.fillStyle = 'white'; // 핀 번호는 항상 흰색
    ctx.font = 'bold 12px Arial'; // 핀 숫자 폰트 크기 조정
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(index + 1, startX, startY); // 1부터 시작하는 순번

    // 시작 좌표 텍스트 (색상)
    ctx.fillStyle = color.text; // 메인 색상으로 텍스트 채우기
    ctx.font = '12px monospace'; // 좌표 폰트 크기 조정
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    ctx.fillText(`${coordStart.x}:${coordStart.y}`, startX + pinRadius + 6, startY);
  }

  function clearCanvas() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }

  function redraw() {
    clearCanvas();
    // 저장된 모든 화살표와 핀 그리기
    arrows.forEach((arrowData, index) => drawArrow(arrowData, index));

    // 현재 그리는 중인 임시 화살표 그리기
    if (isDrawing && currentArrow) {
        // 임시 화살표의 distanceM은 현재 로직에서는 계산되어 있으므로
        drawArrow({ 
            coordStart: currentArrow.coordStart, 
            dragVector: { dx: currentArrow.dragDX, dy: currentArrow.dragDY }, 
            distanceM: currentArrow.distanceM, 
            color: currentArrow.color 
        }, arrows.length);
    }
  }

  // 마우스 움직임에 따른 좌표 표시
  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    if (!isDrawing) {
      const coord = pixelToCoord(x, y);
      coordsDisplay.textContent = `좌표: ${coord.x}:${coord.y}`;
    } else if (currentArrow) {
      coordsDisplay.textContent = `좌표(시작점 고정): ${currentArrow.coordStart.x}:${currentArrow.coordStart.y}`;
    }
  });

  // 마우스 다운 - 드래그 시작점 설정
  canvas.addEventListener('mousedown', (e) => {
    if (isDrawing) return; // 이미 그리기 중이면 무시

    const rect = canvas.getBoundingClientRect();
    const startPxX = e.clientX - rect.left;
    const startPxY = e.clientY - rect.top;
    const coord = pixelToCoord(startPxX, startPxY); // 논리 좌표 저장

    isDrawing = true;

    // 다음 스팟에 적용될 색상 결정
    const nextColor = colorPalette[arrows.length % colorPalette.length];

    currentArrow = {
      startPxX: startPxX, // 캔버스 픽셀 시작점 (임시 저장, dragDX/Y 계산용)
      startPxY: startPxY, // 캔버스 픽셀 시작점 (임시 저장, dragDX/Y 계산용)
      dragDX: 0, // 드래그 가로 변화량 (초기화)
      dragDY: 0, // 드래그 세로 변화량 (초기화)
      coordStart: coord, // 표에 표시될 시작 논리 좌표
      distanceM: 0, // 표에 표시될 거리
      baitInfo: '', 
      targetFish: '', 
      remarks: '', 
      color: nextColor // 현재 그리는 화살표에 색상 할당
    };

    coordsDisplay.textContent = `좌표(시작점 고정): ${coord.x}:${coord.y}`;
    redraw(); // 현재 그리는 화살표도 포함하여 다시 그리기
  });

  // 마우스 무브 - 드래그 변화량 계산 및 그리기
  canvas.addEventListener('mousemove', (e) => {
    if (!isDrawing || !currentArrow) return;

    const rect = canvas.getBoundingClientRect();
    const cursorX = e.clientX - rect.left;
    const cursorY = e.clientY - rect.top;

    // 드래그 방향 벡터 (cursor - 시작점)
    const dragDX = cursorX - currentArrow.startPxX;
    const dragDY = cursorY - currentArrow.startPxY;

    // 반대 방향 화살표의 끝 픽셀 위치
    const arrowEndPxX = currentArrow.startPxX - dragDX;
    const arrowEndPxY = currentArrow.startPxY - dragDY;

    // 픽셀 거리 계산
    const distancePx = Math.sqrt(Math.pow(arrowEndPxX - currentArrow.startPxX, 2) + Math.pow(arrowEndPxY - currentArrow.startPxY, 2));
    
    // 미터 거리 계산 (dragDX, dragDY를 직접 사용, 또는 arrowEndPxX,Y와 startPxX,Y를 사용)
    const distanceM = pixelToMeter(currentArrow.startPxX, currentArrow.startPxY, arrowEndPxX, arrowEndPxY);

    currentArrow.dragDX = dragDX; // 드래그 벡터 저장
    currentArrow.dragDY = dragDY; // 드래그 벡터 저장
    currentArrow.distanceM = distanceM; // 미터 거리 업데이트
    currentArrow.distancePx = distancePx; // 픽셀 거리 (너무 짧은 드래그 판별용)

    redraw(); // 모든 저장된 스팟과 현재 그리는 스팟을 다시 그림
  });

  // 마우스 업 - 화살표 최종 확정 및 목록 저장
  canvas.addEventListener('mouseup', () => {
    if (isDrawing && currentArrow) {
      if (currentArrow.distancePx > 10) { // 너무 짧은 드래그는 무시 (약 10픽셀 미만)
        const now = new Date();
        const timeStr = now.toLocaleDateString('ko-KR', { year: 'numeric', month: '2-digit', day: '2-digit' }) +
                        ' ' + now.toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit', hour12: false });

        const spot = {
          id: Date.now(),
          time: timeStr,
          coordStart: currentArrow.coordStart, // 논리 시작 좌표
          dragVector: { dx: currentArrow.dragDX, dy: currentArrow.dragDY }, // 드래그 벡터 (방향 정보)
          distanceM: currentArrow.distanceM, // 미터 거리
          baitInfo: '', 
          targetFish: '', 
          remarks: '', 
          color: currentArrow.color // 색상 정보
        };

        arrows.push(spot);
        saveArrows();
        addSpotToTable(spot, arrows.length - 1); // 새로 추가된 스팟의 인덱스 전달

      }
    }
    isDrawing = false;
    currentArrow = null;
    redraw(); // 최종 상태로 다시 그리기 (임시 화살표 제거)
    coordsDisplay.textContent = "좌표: 0:0";
  });

  canvas.addEventListener('mouseleave', () => {
    // 캔버스 밖으로 나가면 그리기 중단 (임시 화살표는 사라짐)
    if (isDrawing) {
      isDrawing = false;
      currentArrow = null;
      redraw(); // 임시 화살표 사라진 상태로 다시 그리기
      coordsDisplay.textContent = '좌표: 0:0';
    }
  });

  // 저장한 스팟을 표에 추가
  function addSpotToTable(spot, index) {
    const tr = document.createElement('tr');
    tr.dataset.id = spot.id; 

    tr.innerHTML = `
      <td>${index + 1}</td>
      <td>${spot.time}</td>
      <td>${formatCoord(spot.coordStart)}</td>
      <td>${spot.distanceM}</td>
      <td class="editable" data-field="baitInfo" data-maxlength="50" contenteditable="true">${escapeHtml(spot.baitInfo)}</td>
      <td class="editable" data-field="targetFish" data-maxlength="30" contenteditable="true">${escapeHtml(spot.targetFish)}</td>
      <td class="editable" data-field="remarks" data-maxlength="100" contenteditable="true">${escapeHtml(spot.remarks)}</td>
      <td><button class="delete-btn" aria-label="스팟 삭제">삭제</button></td>
    `;

    // 편집 가능한 셀에 이벤트 리스너 추가
    tr.querySelectorAll('.editable').forEach(cell => {
      // 입력 시 최대 길이 제한
      cell.addEventListener('input', (e) => {
        const maxLength = parseInt(e.target.dataset.maxlength, 10);
        if (e.target.textContent.length > maxLength) {
          e.target.textContent = e.target.textContent.substring(0, maxLength);
          // 커서를 텍스트 끝으로 이동 (UX 개선)
          const range = document.createRange();
          const sel = window.getSelection();
          range.setStart(e.target.firstChild || e.target, e.target.textContent.length);
          range.collapse(true);
          sel.removeAllRanges();
          sel.addRange(range);
        }
      });
      cell.addEventListener('blur', (e) => { // 셀 편집이 끝나면 (포커스를 잃으면)
        updateSpotData(spot.id, e.target.dataset.field, e.target.textContent);
      });
      // Enter 키 눌렀을 때도 저장하고 포커스 해제
      cell.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault(); // 새 줄 삽입 방지
          e.target.blur(); // 포커스 해제하여 blur 이벤트 트리거
        }
      });
    });

    // 삭제 버튼 클릭 이벤트
    tr.querySelector('button.delete-btn').addEventListener('click', () => {
      if (confirm('이 스팟을 삭제하시겠습니까?')) {
        removeSpotById(spot.id);
      }
    });

    spotTableBody.appendChild(tr);
  }

  // 테이블 데이터 수정 시 배열 및 로컬스토리지 업데이트
  function updateSpotData(id, field, value) {
    const spotIndex = arrows.findIndex(s => s.id === id);
    if (spotIndex !== -1) {
      arrows[spotIndex][field] = value;
      saveArrows();
    }
  }

  // 좌표 콜론 (:) 표기 포맷 함수
  function formatCoord(coord) {
    return `${coord.x}:${coord.y}`;
  }

  // 스팟 ID로 삭제 처리
  function removeSpotById(id) {
    arrows = arrows.filter(s => s.id !== id);
    saveArrows();
    refreshTable(); // 테이블 새로고침 (순번 재정렬 위해)
    redraw(); // 캔버스 다시 그리기 (핀, 화살표 재정렬 위해)
  }

  // 테이블 전체를 지우고 배열 데이터로 다시 그리기 (삭제 시 순번 재정렬용)
  function refreshTable() {
    spotTableBody.innerHTML = ''; // 기존 테이블 내용 모두 삭제
    arrows.forEach((spot, index) => addSpotToTable(spot, index)); // 모든 스팟을 순번 새로 부여해서 추가
  }

  // 로컬스토리지 저장
  function saveArrows() {
    localStorage.setItem('fishingSpots', JSON.stringify(arrows));
  }

  // 로컬스토리지에서 불러와 테이블 채우기
  function loadArrowsFromStorage() {
    const data = localStorage.getItem('fishingSpots');
    arrows = data ? JSON.parse(data) : [];
    
    arrows.forEach((spot, index) => {
        // 기존 데이터 호환 (이전 버전에서 저장된 데이터 구조를 새 구조로 마이그레이션)
        // startX, Y, endX, Y 가 있는 구 버전 데이터 -> dragVector 계산
        if (spot.startX !== undefined && spot.startY !== undefined && spot.endX !== undefined && spot.endY !== undefined) {
             spot.dragVector = {
                 dx: spot.startX - (spot.endX || 0), // endX/Y가 없을 경우 0 처리
                 dy: spot.startY - (spot.endY || 0)
             };
             // 불필요한 기존 필드 삭제
             delete spot.startX;
             delete spot.startY;
             delete spot.endX;
             delete spot.endY;
             delete spot.distancePx;
             console.warn(`Migrating old spot data (ID: ${spot.id}). Pixel coordinates converted to dragVector.`);
        }
        // dragVector가 없거나 유효하지 않으면 기본값 할당
        if (!spot.dragVector || spot.dragVector.dx === undefined || spot.dragVector.dy === undefined) {
             console.warn(`dragVector missing or invalid for spot (ID: ${spot.id}). Assigning default.`);
             spot.dragVector = { dx: 20, dy: 20 }; // 기본값 설정
        }

        // color 필드가 string으로 저장된 경우 {main, text} 객체로 변환
        if (typeof spot.color === 'string') {
            const foundColor = colorPalette.find(c => c.text === spot.color);
            spot.color = foundColor || colorPalette[index % colorPalette.length]; 
        } else if (!spot.color) { // color 필드가 아예 없거나 null인 경우
            spot.color = colorPalette[index % colorPalette.length];
        }

        // 기타 필드 누락 여부 확인 및 기본값 할당
        if (spot.baitInfo === undefined) spot.baitInfo = '';
        if (spot.targetFish === undefined) spot.targetFish = '';
        if (spot.remarks === undefined) spot.remarks = '';
    });
    refreshTable(); // 테이블을 로드된 데이터로 채움
  }

  // XSS 방지용 텍스트 이스케이프 처리 (HTML 태그 등 방지)
  function escapeHtml(text) {
    if (typeof text !== 'string') return text; // 텍스트가 아니면 그대로 반환
    return text.replace(/[&<>"']/g, m => ({
      '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
    })[m]);
  }

  // --- 공유 및 가져오기 기능 ---
  shareSpotsBtn.addEventListener('click', async () => {
      shareSpotsBtn.disabled = true;
      shareSpotsBtn.textContent = '처리 중...';

      try {
          // 공유할 데이터는 최소화된 상태 (dragVector 포함)
          const serializableArrows = arrows.map(spot => ({
            id: spot.id,
            time: spot.time,
            coordStart: spot.coordStart,
            dragVector: spot.dragVector, // dragVector (dx, dy) 직접 저장
            distanceM: spot.distanceM,
            baitInfo: spot.baitInfo,
            targetFish: spot.targetFish,
            remarks: spot.remarks,
            color: spot.color.text // color 객체 대신 color.text (string)만 저장
          }));
          const dataToShare = JSON.stringify(serializableArrows);
          const compressedData = LZString.compressToEncodedURIComponent(dataToShare); // compressToEncodedURIComponent 사용
          
          await navigator.clipboard.writeText(compressedData);
          alert('스팟 정보가 클립보드에 복사되었습니다! 친구에게 공유해 보세요.');
      } catch (err) {
          console.error('클립보드 복사 실패:', err);
          alert('클립보드 복사에 실패했습니다.\n\n* 웹 페이지를 "file:///..." 경로가 아닌, 로컬 웹 서버(예: http://localhost)로 열었는지 확인해주세요.\n\n오류: ' + err.message);
          // 대안: textarea에 표시하고 사용자에게 수동 복사 요청
          importArea.style.display = 'flex';
          importTextInput.value = compressedData;
          importTextInput.select();
          alert('클립보드 복사에 실패했습니다. 위 텍스트 상자에서 직접 복사해주세요.');
      } finally {
          shareSpotsBtn.disabled = false;
          shareSpotsBtn.textContent = '스팟 공유하기';
      }
  });

  importSpotsBtn.addEventListener('click', () => {
      importArea.style.display = importArea.style.display === 'flex' ? 'none' : 'flex';
      importTextInput.value = ''; // 입력창 초기화
      if (importArea.style.display === 'flex') {
        importTextInput.focus();
      }
  });

  loadImportDataBtn.addEventListener('click', () => {
      const inputData = importTextInput.value.trim();
      if (!inputData) {
          alert('가져올 스팟 데이터가 비어 있습니다.');
          return;
      }
      try {
          const decompressedData = LZString.decompressFromEncodedURIComponent(inputData); // decompressFromEncodedURIComponent 사용
          if (decompressedData === null) { // decompressFromEncodedURIComponent가 null을 반환할 수 있음 (잘못된 입력)
            throw new Error("데이터 압축 해제 실패. 입력값이 올바른지 확인해주세요. (Null data)");
          }
          if (decompressedData === "") { // 빈 문자열인 경우도 처리
             throw new Error("압축 해제된 데이터가 비어 있습니다. (Empty data)");
          }

          let newArrows = JSON.parse(decompressedData);

          if (!Array.isArray(newArrows)) {
              throw new Error('유효하지 않은 스팟 데이터 형식입니다. 배열이 아닙니다.');
          }

          newArrows = newArrows.map(s => {
            // 필수 필드 및 새 구조에 맞게 유효성 검사 및 복원
            if (!s.id || !s.coordStart || !s.dragVector || s.dragVector.dx === undefined || s.dragVector.dy === undefined || !s.color) {
                console.warn("Invalid spot data structure in imported data:", s);
                return null; // 유효하지 않은 항목 필터링
            }
            // LZString 저장 시 color.text(string)로 저장되었으므로 다시 colorPalette의 객체로 매핑
            const mappedColor = colorPalette.find(c => c.text === s.color);
            s.color = mappedColor || colorPalette[0]; // 매핑된 색상이 없거나 color 객체가 아닌 경우 기본 색상 할당
            
            // 기타 필드 누락시 기본값 할당 (로드 시 항상 최신 스키마 유지)
            s.baitInfo = s.baitInfo === undefined ? '' : s.baitInfo;
            s.targetFish = s.targetFish === undefined ? '' : s.targetFish;
            s.remarks = s.remarks === undefined ? '' : s.remarks;

            return s;
          }).filter(Boolean); // null 값 필터링

          arrows = newArrows;
          saveArrows();
          refreshTable();
          redraw();
          importArea.style.display = 'none'; // 입력창 숨김
          alert('스팟 정보를 성공적으로 불러왔습니다!');

      } catch (e) {
          console.error('데이터 가져오기 실패:', e);
          alert('스팟 데이터를 가져오는데 실패했습니다. 올바른 형식인지 확인해주세요.\n(오류: ' + e.message + ')');
      }
  });

  clearAllSpotsBtn.addEventListener('click', () => {
    if (confirm('정말 모든 스팟을 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.')) {
      arrows = [];
      saveArrows();
      refreshTable();
      redraw();
      alert('모든 스팟이 삭제되었습니다.');
    }
  });

})();
</script>

</body>
</html>
